[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "ARDUINO_MODELS",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "validate_model",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_available_models",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_display_names",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "validate_model",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_display_names",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "validate_model",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "ARDUINO_MODELS",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_available_models",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_display_names",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "validate_model",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_recommended_model_for_leds",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_power_requirements",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_matrix_dimensions",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_memory_usage",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_refresh_rate",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "get_optimal_pin_configuration",
        "importPath": "arduino_models",
        "description": "arduino_models",
        "isExtraImport": true,
        "detail": "arduino_models",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "matrix_config",
        "description": "matrix_config",
        "isExtraImport": true,
        "detail": "matrix_config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "matrix_config",
        "description": "matrix_config",
        "isExtraImport": true,
        "detail": "matrix_config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "matrix_config",
        "description": "matrix_config",
        "isExtraImport": true,
        "detail": "matrix_config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "matrix_config",
        "description": "matrix_config",
        "isExtraImport": true,
        "detail": "matrix_config",
        "documentation": {}
    },
    {
        "label": "MatrixConfig",
        "importPath": "matrix_config",
        "description": "matrix_config",
        "isExtraImport": true,
        "detail": "matrix_config",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "ArduinoGenerator",
        "importPath": "arduino_generator",
        "description": "arduino_generator",
        "isExtraImport": true,
        "detail": "arduino_generator",
        "documentation": {}
    },
    {
        "label": "ArduinoGenerator",
        "importPath": "arduino_generator",
        "description": "arduino_generator",
        "isExtraImport": true,
        "detail": "arduino_generator",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "serial",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "serial",
        "description": "serial",
        "detail": "serial",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageSequence",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "colorsys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorsys",
        "description": "colorsys",
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "mimetypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mimetypes",
        "description": "mimetypes",
        "detail": "mimetypes",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "hardware",
        "importPath": "matrix_hardware",
        "description": "matrix_hardware",
        "isExtraImport": true,
        "detail": "matrix_hardware",
        "documentation": {}
    },
    {
        "label": "WiringDiagramGenerator",
        "importPath": "wiring_diagram_generator",
        "description": "wiring_diagram_generator",
        "isExtraImport": true,
        "detail": "wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "WiringDiagramGenerator",
        "importPath": "wiring_diagram_generator",
        "description": "wiring_diagram_generator",
        "isExtraImport": true,
        "detail": "wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "http.server",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.server",
        "description": "http.server",
        "detail": "http.server",
        "documentation": {}
    },
    {
        "label": "socketserver",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socketserver",
        "description": "socketserver",
        "detail": "socketserver",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "mock_open",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "mock_open",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "get_test_config",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "get_test_config",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "get_test_config",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "get_test_config",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "get_test_config",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "cmd_controller",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_start",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_generate",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_design",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_wiring",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_config",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_test",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "cmd_info",
        "importPath": "commands",
        "description": "commands",
        "isExtraImport": true,
        "detail": "commands",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matrix",
        "description": "matrix",
        "detail": "matrix",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "MatrixDesign",
        "importPath": "matrix_design_library",
        "description": "matrix_design_library",
        "isExtraImport": true,
        "detail": "matrix_design_library",
        "documentation": {}
    },
    {
        "label": "get_env_config",
        "importPath": "web_server",
        "description": "web_server",
        "isExtraImport": true,
        "detail": "web_server",
        "documentation": {}
    },
    {
        "label": "ServerConfig",
        "importPath": "web_server",
        "description": "web_server",
        "isExtraImport": true,
        "detail": "web_server",
        "documentation": {}
    },
    {
        "label": "UnifiedMatrixWebServer",
        "importPath": "web_server",
        "description": "web_server",
        "isExtraImport": true,
        "detail": "web_server",
        "documentation": {}
    },
    {
        "label": "setup_signal_handlers",
        "importPath": "web_server",
        "description": "web_server",
        "isExtraImport": true,
        "detail": "web_server",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "web_server",
        "description": "web_server",
        "isExtraImport": true,
        "detail": "web_server",
        "documentation": {}
    },
    {
        "label": "cmd_controller",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_start",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_generate",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_design",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_wiring",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_config",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_test",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_info",
        "importPath": "modules.commands",
        "description": "modules.commands",
        "isExtraImport": true,
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "ArduinoGenerator",
        "kind": 6,
        "importPath": "modules.arduino_generator",
        "description": "modules.arduino_generator",
        "peekOfCode": "class ArduinoGenerator:\n    def __init__(self):\n        self.config = config\n    def generate_code(\n        self,\n        model_key,\n        matrix_width=None,\n        matrix_height=None,\n        data_pin=None,\n        brightness=None,",
        "detail": "modules.arduino_generator",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "modules.arduino_generator",
        "description": "modules.arduino_generator",
        "peekOfCode": "def main():\n    \"\"\"Interactive Arduino code generator\"\"\"\n    print(\"🔧 Arduino Code Generator\")\n    print(\"=\" * 40)\n    generator = ArduinoGenerator()\n    # Show available models\n    print(\"\\nAvailable Arduino Models:\")\n    for i, (key, model) in enumerate(ARDUINO_MODELS.items(), 1):\n        print(f\"  {i}. {model['display_name']} ({key})\")\n    try:",
        "detail": "modules.arduino_generator",
        "documentation": {}
    },
    {
        "label": "find_arduino",
        "kind": 2,
        "importPath": "modules.arduino_generator",
        "description": "modules.arduino_generator",
        "peekOfCode": "def find_arduino():\n    \"\"\"Standalone function to find and test Arduino connections\"\"\"\n    print(\"🔍 Arduino Port Scanner\")\n    print(\"=\" * 30)\n    if not SERIAL_AVAILABLE:\n        print(\"❌ PySerial not available. Install with: pip install pyserial\")\n        return\n    generator = ArduinoGenerator()\n    # List all serial ports\n    all_ports = generator.list_serial_ports()",
        "detail": "modules.arduino_generator",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def get_model_info(model_key):\n    \"\"\"Get information for a specific Arduino model\"\"\"\n    return ARDUINO_MODELS.get(model_key.lower())\ndef get_available_models():\n    \"\"\"Get list of available Arduino models\"\"\"\n    return list(ARDUINO_MODELS.keys())\ndef get_model_display_names():\n    \"\"\"Get dictionary of model keys to display names\"\"\"\n    return {key: model[\"display_name\"] for key, model in ARDUINO_MODELS.items()}\ndef validate_model(model_key):",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "get_available_models",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def get_available_models():\n    \"\"\"Get list of available Arduino models\"\"\"\n    return list(ARDUINO_MODELS.keys())\ndef get_model_display_names():\n    \"\"\"Get dictionary of model keys to display names\"\"\"\n    return {key: model[\"display_name\"] for key, model in ARDUINO_MODELS.items()}\ndef validate_model(model_key):\n    \"\"\"Validate if a model key exists\"\"\"\n    return model_key.lower() in ARDUINO_MODELS\ndef get_recommended_model_for_leds(num_leds):",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "get_model_display_names",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def get_model_display_names():\n    \"\"\"Get dictionary of model keys to display names\"\"\"\n    return {key: model[\"display_name\"] for key, model in ARDUINO_MODELS.items()}\ndef validate_model(model_key):\n    \"\"\"Validate if a model key exists\"\"\"\n    return model_key.lower() in ARDUINO_MODELS\ndef get_recommended_model_for_leds(num_leds):\n    \"\"\"Get recommended Arduino model based on LED count\"\"\"\n    recommendations = []\n    for key, model in ARDUINO_MODELS.items():",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "validate_model",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def validate_model(model_key):\n    \"\"\"Validate if a model key exists\"\"\"\n    return model_key.lower() in ARDUINO_MODELS\ndef get_recommended_model_for_leds(num_leds):\n    \"\"\"Get recommended Arduino model based on LED count\"\"\"\n    recommendations = []\n    for key, model in ARDUINO_MODELS.items():\n        if num_leds <= model[\"max_leds_recommended\"]:\n            recommendations.append(\n                {",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "get_recommended_model_for_leds",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def get_recommended_model_for_leds(num_leds):\n    \"\"\"Get recommended Arduino model based on LED count\"\"\"\n    recommendations = []\n    for key, model in ARDUINO_MODELS.items():\n        if num_leds <= model[\"max_leds_recommended\"]:\n            recommendations.append(\n                {\n                    \"key\": key,\n                    \"name\": model[\"display_name\"],\n                    \"memory_efficiency\": (model[\"memory_sram\"] - (num_leds * 3))",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_power_requirements",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def calculate_power_requirements(num_leds, brightness_percent=100):\n    \"\"\"Calculate power requirements for LED matrix using math functions\"\"\"\n    # Each WS2812B LED can draw up to 60mA at full brightness (20mA per color channel)\n    max_current_per_led = 0.06  # 60mA in Amps\n    voltage = 5.0  # 5V supply\n    # Calculate actual current based on brightness\n    brightness_factor = brightness_percent / 100.0\n    actual_current_per_led = max_current_per_led * brightness_factor\n    # Total current and power calculations\n    total_current = num_leds * actual_current_per_led",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_matrix_dimensions",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def calculate_matrix_dimensions(num_leds):\n    \"\"\"Calculate optimal matrix dimensions for given LED count\"\"\"\n    # Find factors of num_leds to suggest rectangular matrices\n    factors = []\n    sqrt_leds = int(math.sqrt(num_leds))\n    for i in range(1, sqrt_leds + 1):\n        if num_leds % i == 0:\n            width = i\n            height = num_leds // i\n            aspect_ratio = max(width, height) / min(width, height)",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_memory_usage",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def calculate_memory_usage(width, height, model_key=\"uno\"):\n    \"\"\"Calculate memory usage for matrix configuration\"\"\"\n    num_leds = width * height\n    model = get_model_info(model_key)\n    if not model:\n        return None\n    # Calculate memory requirements\n    led_array_bytes = num_leds * 3  # 3 bytes per LED (RGB)\n    program_overhead = 1024  # Estimated program overhead in bytes\n    available_sram = model[\"memory_sram\"]",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "calculate_refresh_rate",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def calculate_refresh_rate(num_leds, baud_rate=500000):\n    \"\"\"Calculate theoretical maximum refresh rate for LED matrix\"\"\"\n    # Each LED requires 3 bytes (RGB), plus protocol overhead\n    bytes_per_frame = num_leds * 3\n    protocol_overhead = 0.1  # 10% overhead for serial protocol\n    # Calculate effective data rate\n    effective_baud = baud_rate * (1 - protocol_overhead)\n    bytes_per_second = effective_baud / 8  # Convert bits to bytes\n    # Calculate maximum FPS using math functions\n    max_fps = math.floor(bytes_per_second / bytes_per_frame)",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "get_optimal_pin_configuration",
        "kind": 2,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "def get_optimal_pin_configuration(model_key, num_parallel_strips=1):\n    \"\"\"Get optimal pin configuration for multi-strip setups\"\"\"\n    model = get_model_info(model_key)\n    if not model:\n        return None\n    # Calculate optimal pin spacing using math\n    if model_key in [\"esp32\"]:\n        # ESP32 has many GPIO pins, use optimal spacing\n        base_pin = model[\"default_pin\"]\n        pin_spacing = max(2, math.ceil(math.log2(num_parallel_strips)))",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "ARDUINO_MODELS",
        "kind": 5,
        "importPath": "modules.arduino_models",
        "description": "modules.arduino_models",
        "peekOfCode": "ARDUINO_MODELS = {\n    \"uno\": {\n        \"name\": \"Arduino Uno\",\n        \"display_name\": \"Arduino Uno\",\n        \"voltage\": \"5V\",\n        \"default_pin\": 6,\n        \"memory_sram\": 2048,  # bytes\n        \"memory_flash\": 32768,  # bytes\n        \"needs_level_shifter\": False,\n        \"max_leds_recommended\": 500,",
        "detail": "modules.arduino_models",
        "documentation": {}
    },
    {
        "label": "cmd_controller",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_controller(args):\n    \"\"\"\n    Starts the web-based LED Matrix Controller with async support.\n    Returns:\n        bool: True if the controller starts successfully, False if an error occurs.\n    \"\"\"\n    print(\"🎮 Starting LED Matrix Controller...\")\n    # Check for async support\n    import importlib.util\n    use_async = importlib.util.find_spec(\"aiohttp\") is not None",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_start",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_start(args):\n    \"\"\"\n    Starts the complete LED matrix system, launching both the web-based matrix controller and the unified web server in separate daemon threads.\n    Returns:\n        bool: True if services are stopped via keyboard interrupt, False if an error occurs during startup.\n    \"\"\"\n    print(\"🚀 Starting Complete LED Matrix System...\")\n    print(\"   - Web-based Matrix Controller\")\n    print(\"   - Control Interface Server\")\n    print(\"   - Documentation Server\")",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_generate",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_generate(args):\n    \"\"\"\n    Generates Arduino code for a specified LED matrix model, with options for model comparison, organized output, and upload instructions.\n    Returns:\n        bool: True if code generation succeeds or model comparison is shown; False if an error occurs or the model is invalid.\n    \"\"\"\n    print(\"🔧 Generating Arduino code for {}...\".format(args.model))\n    try:\n        from arduino_generator import ArduinoGenerator\n        from arduino_models import validate_model",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_design",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_design(args):\n    \"\"\"\n    Launches the LED Matrix Design Library to create, export, or generate code for matrix designs.\n    Depending on the arguments, this function can create sample designs, enter an interactive mode for custom pattern creation (including rainbow, gradient, checkerboard, and plasma effects), export designs, or generate Arduino code. Returns True on success, or False if an error occurs.\n    \"\"\"\n    print(\"🎨 LED Matrix Design Library...\")\n    try:\n        from matrix_design_library import MatrixDesign, create_sample_designs\n        if args.samples:\n            print(\"Creating sample designs...\")",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_wiring",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_wiring(args):\n    \"\"\"\n    Generates wiring diagrams, configuration files, and a shopping list for a specified LED matrix controller and matrix size.\n    Creates a markdown wiring guide, exports a JSON configuration, and generates a shopping list JSON file based on the provided controller, matrix dimensions, data pin, and power supply. Prints a summary of the wiring configuration, including power requirements and estimated cost. Returns True on success, or False if an error occurs.\n    \"\"\"\n    print(\"📋 Generating wiring diagrams for {}...\".format(args.controller))\n    try:\n        from wiring_diagram_generator import WiringDiagramGenerator\n        generator = WiringDiagramGenerator()\n        # Generate markdown guide",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_config",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_config(args):\n    \"\"\"\n    Configures LED matrix settings, allowing users to view, interactively update, or set configuration values for the matrix.\n    Depending on the provided arguments, this function can display the current configuration, prompt the user for interactive updates, or set individual configuration parameters such as matrix width, height, brightness, and serial port. Changes are saved persistently. Returns True on success, or False if an error occurs.\n    \"\"\"\n    print(\"⚙️ Matrix Configuration...\")\n    try:\n        from matrix_config import config\n        if args.show:\n            print(\"Current Configuration:\")",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_test",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_test(args):\n    \"\"\"\n    Runs the LED matrix test suite, either for a specific module or the entire project.\n    If `args.module` is specified, runs tests for that module using the unittest framework. Otherwise, executes the full test suite. Prints status messages and returns `True` if tests pass, `False` otherwise.\n    \"\"\"\n    print(\"🧪 Running LED Matrix Test Suite...\")\n    try:\n        if args.module:\n            # Run specific test module\n            import unittest",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "cmd_info",
        "kind": 2,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "def cmd_info(args):\n    \"\"\"\n    Displays detailed information about the LED Matrix Project, including matrix configuration, available modules, hardware status, and test suite availability.\n    Returns:\n        bool: True if information is displayed successfully, False if an error occurs.\n    \"\"\"\n    print(\"ℹ️ LED Matrix Project Information\")\n    print()\n    try:\n        # Project status",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "current_dir = os.path.dirname(os.path.abspath(__file__))\nmodules_dir = os.path.join(current_dir, \"..\", \"modules\")\nsys.path.insert(0, current_dir)\nsys.path.insert(0, modules_dir)\ndef cmd_controller(args):\n    \"\"\"\n    Starts the web-based LED Matrix Controller with async support.\n    Returns:\n        bool: True if the controller starts successfully, False if an error occurs.\n    \"\"\"",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "modules_dir",
        "kind": 5,
        "importPath": "modules.commands",
        "description": "modules.commands",
        "peekOfCode": "modules_dir = os.path.join(current_dir, \"..\", \"modules\")\nsys.path.insert(0, current_dir)\nsys.path.insert(0, modules_dir)\ndef cmd_controller(args):\n    \"\"\"\n    Starts the web-based LED Matrix Controller with async support.\n    Returns:\n        bool: True if the controller starts successfully, False if an error occurs.\n    \"\"\"\n    print(\"🎮 Starting LED Matrix Controller...\")",
        "detail": "modules.commands",
        "documentation": {}
    },
    {
        "label": "MatrixConfig",
        "kind": 6,
        "importPath": "modules.matrix_config",
        "description": "modules.matrix_config",
        "peekOfCode": "class MatrixConfig:\n    \"\"\"Centralized configuration management\"\"\"\n    DEFAULT_CONFIG = {\n        \"matrix_width\": 21,\n        \"matrix_height\": 24,\n        \"leds_per_meter\": 144,\n        \"wiring_pattern\": \"serpentine\",\n        \"serial_port\": \"COM3\",\n        \"baud_rate\": 500000,\n        \"brightness\": 128,",
        "detail": "modules.matrix_config",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "modules.matrix_config",
        "description": "modules.matrix_config",
        "peekOfCode": "config = MatrixConfig()",
        "detail": "modules.matrix_config",
        "documentation": {}
    },
    {
        "label": "MatrixConfigGenerator",
        "kind": 6,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "class MatrixConfigGenerator:\n    def __init__(self):\n        # Use shared config as base, allow overrides\n        defaults = {\n            \"width\": 21,\n            \"height\": 24,\n            \"leds_per_meter\": 144,\n            \"wiring_pattern\": \"serpentine\",\n            \"physical_width\": 146,\n            \"physical_height\": 167,",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MatrixController",
        "kind": 6,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "class MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate\n        self.ser = None\n        self.matrix_data = np.zeros((MATRIX_HEIGHT, MATRIX_WIDTH, 3), dtype=np.uint8)\n    def connect(self):\n        \\\"\\\"\\\"Connect to Arduino\\\"\\\"\\\"\n        try:\n            self.ser = serial.Serial(self.port, self.baud_rate, timeout=1)",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "def main():\n    \"\"\"Interactive configuration generator\"\"\"\n    print(\"LED Matrix Configuration Generator\")\n    print(\"=\" * 40)\n    generator = MatrixConfigGenerator()\n    # Get user input\n    try:\n        # Helper to safely get int from input or config\n        def safe_int_input(prompt, config_value, default=0):\n            val = input(prompt)",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MATRIX_WIDTH",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MATRIX_WIDTH = {self.config['width']}\nMATRIX_HEIGHT = {self.config['height']}\nNUM_LEDS = {specs['total_leds']}\nLED_SPACING = {specs['led_spacing']:.2f}  # mm\nBRIGHTNESS = {self.config['brightness']}\nWIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MATRIX_HEIGHT",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MATRIX_HEIGHT = {self.config['height']}\nNUM_LEDS = {specs['total_leds']}\nLED_SPACING = {specs['led_spacing']:.2f}  # mm\nBRIGHTNESS = {self.config['brightness']}\nWIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "NUM_LEDS",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "NUM_LEDS = {specs['total_leds']}\nLED_SPACING = {specs['led_spacing']:.2f}  # mm\nBRIGHTNESS = {self.config['brightness']}\nWIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "LED_SPACING",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "LED_SPACING = {specs['led_spacing']:.2f}  # mm\nBRIGHTNESS = {self.config['brightness']}\nWIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "BRIGHTNESS",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "BRIGHTNESS = {self.config['brightness']}\nWIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "WIRING_PATTERN",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "WIRING_PATTERN = \"{self.config['wiring_pattern']}\"\n# Physical dimensions (mm)\nPHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "PHYSICAL_WIDTH",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "PHYSICAL_WIDTH = {self.config['physical_width']}\nPHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "PHYSICAL_HEIGHT",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "PHYSICAL_HEIGHT = {self.config['physical_height']}\n# Power specifications\nMAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MAX_CURRENT_PER_LED",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MAX_CURRENT_PER_LED = {specs['max_current_per_led']}  # Amps\nMAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MAX_CURRENT_TOTAL",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MAX_CURRENT_TOTAL = {specs['max_current_total']:.3f}  # Amps\nACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "ACTUAL_CURRENT",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "ACTUAL_CURRENT = {specs['actual_current']:.3f}  # Amps at current brightness\n# Performance specifications\nMAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate\n        self.ser = None",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MAX_FRAME_RATE",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MAX_FRAME_RATE = {specs['max_frame_rate']}  # FPS\nMEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate\n        self.ser = None\n        self.matrix_data = np.zeros((MATRIX_HEIGHT, MATRIX_WIDTH, 3), dtype=np.uint8)\n    def connect(self):",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "MEMORY_USAGE",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "MEMORY_USAGE = {specs['memory_usage']}  # bytes\nDATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate\n        self.ser = None\n        self.matrix_data = np.zeros((MATRIX_HEIGHT, MATRIX_WIDTH, 3), dtype=np.uint8)\n    def connect(self):\n        \\\"\\\"\\\"Connect to Arduino\\\"\\\"\\\"",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "DATA_RATE",
        "kind": 5,
        "importPath": "modules.matrix_config_generator",
        "description": "modules.matrix_config_generator",
        "peekOfCode": "DATA_RATE = {specs['data_rate']}  # bytes/second\nclass MatrixController:\n    def __init__(self, port='COM3', baud_rate=500000):\n        self.port = port\n        self.baud_rate = baud_rate\n        self.ser = None\n        self.matrix_data = np.zeros((MATRIX_HEIGHT, MATRIX_WIDTH, 3), dtype=np.uint8)\n    def connect(self):\n        \\\"\\\"\\\"Connect to Arduino\\\"\\\"\\\"\n        try:",
        "detail": "modules.matrix_config_generator",
        "documentation": {}
    },
    {
        "label": "WebMatrixController",
        "kind": 6,
        "importPath": "modules.matrix_controller",
        "description": "modules.matrix_controller",
        "peekOfCode": "class WebMatrixController:\n    def __init__(self, port=8080, use_async=True):\n        \"\"\"\n        Initialize the WebMatrixController with matrix configuration and async web server support.\n        Sets up matrix dimensions, state variables, data buffer, thread pool for CPU-intensive tasks,\n        and WebSocket connections for real-time updates.\n        \"\"\"\n        logger.info(f\"INIT: Initializing WebMatrixController on port {port}\")\n        # Matrix properties from shared config\n        self.config = config",
        "detail": "modules.matrix_controller",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "modules.matrix_controller",
        "description": "modules.matrix_controller",
        "peekOfCode": "logger = logging.getLogger(\"MatrixController\")\n# Robust resampling filter imports for Pillow compatibility\ntry:\n    from PIL import Image as PILImage\n    Resampling = getattr(PILImage, \"Resampling\", None)\n    if Resampling is not None:\n        LANCZOS_RESAMPLE = Resampling.LANCZOS\n        NEAREST_RESAMPLE = Resampling.NEAREST\n    else:\n        LANCZOS_RESAMPLE = getattr(",
        "detail": "modules.matrix_controller",
        "documentation": {}
    },
    {
        "label": "MatrixDesign",
        "kind": 6,
        "importPath": "modules.matrix_design_library",
        "description": "modules.matrix_design_library",
        "peekOfCode": "class MatrixDesign:\n    def __init__(self, width=21, height=24):\n        self.width = width\n        self.height = height\n        self.frames = []\n        self.current_frame = 0\n        self.frame_rate = 10\n        self.custom_palette = [\n            \"#ff0000\",\n            \"#00ff00\",",
        "detail": "modules.matrix_design_library",
        "documentation": {}
    },
    {
        "label": "create_sample_designs",
        "kind": 2,
        "importPath": "modules.matrix_design_library",
        "description": "modules.matrix_design_library",
        "peekOfCode": "def create_sample_designs():\n    \"\"\"Create sample designs for testing\"\"\"\n    # Create a rainbow design\n    rainbow_design = MatrixDesign(21, 24)\n    rainbow_design.generate_rainbow()\n    rainbow_design.export_design(\"sample_rainbow.json\")\n    rainbow_design.export_as_image(\"sample_rainbow.png\")\n    # Create a gradient design\n    gradient_design = MatrixDesign(21, 24)\n    gradient_design.generate_gradient(\"#ff0000\", \"#0000ff\", \"horizontal\")",
        "detail": "modules.matrix_design_library",
        "documentation": {}
    },
    {
        "label": "MatrixHardware",
        "kind": 6,
        "importPath": "modules.matrix_hardware",
        "description": "modules.matrix_hardware",
        "peekOfCode": "class MatrixHardware:\n    \"\"\"Unified hardware communication interface\"\"\"\n    def __init__(self):\n        self.ser = None\n        self.connection_mode = config.get(\"connection_mode\", \"USB\")\n    def connect(self, mode=None, port=None, esp32_ip=None):\n        \"\"\"Connect to matrix hardware\"\"\"\n        if mode is not None:\n            self.connection_mode = mode\n        try:",
        "detail": "modules.matrix_hardware",
        "documentation": {}
    },
    {
        "label": "hardware",
        "kind": 5,
        "importPath": "modules.matrix_hardware",
        "description": "modules.matrix_hardware",
        "peekOfCode": "hardware = MatrixHardware()",
        "detail": "modules.matrix_hardware",
        "documentation": {}
    },
    {
        "label": "ServerConfig",
        "kind": 6,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "class ServerConfig:\n    port: int = int(os.getenv(\"WEB_SERVER_PORT\", 3000))\n    host: str = os.getenv(\"WEB_SERVER_HOST\", \"localhost\")\n    control_path: str = os.getenv(\"CONTROL_PATH\", \"sites/control\")\n    docs_path: str = os.getenv(\"DOCS_PATH\", \"sites/docs\")\n    api_proxy_port: int = int(os.getenv(\"API_PROXY_PORT\", 8080))\n    enable_cors: bool = os.getenv(\"ENABLE_CORS\", \"true\").lower() == \"true\"\n    enable_caching: bool = os.getenv(\"ENABLE_CACHING\", \"true\").lower() == \"true\"\nclass UnifiedMatrixWebServer:\n    def __init__(self, port=None):",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "UnifiedMatrixWebServer",
        "kind": 6,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "class UnifiedMatrixWebServer:\n    def __init__(self, port=None):\n        # Use environment variable or passed port\n        if port is None:\n            port = int(os.getenv(\"WEB_SERVER_PORT\", 3000))\n        self.config = ServerConfig(port=port)\n        # Use environment variable for sites directory if available\n        sites_base = os.getenv(\"SITES_DIR\", str(Path(__file__).parent.parent / \"sites\"))\n        self.sites_dir = Path(sites_base)\n        self.control_dir = self.sites_dir / \"control\"",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "get_env_config",
        "kind": 2,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "def get_env_config():\n    \"\"\"Get environment configuration for debugging\"\"\"\n    env_vars = {\n        \"WEB_SERVER_PORT\": os.getenv(\"WEB_SERVER_PORT\"),\n        \"WEB_SERVER_HOST\": os.getenv(\"WEB_SERVER_HOST\"),\n        \"API_PROXY_PORT\": os.getenv(\"API_PROXY_PORT\"),\n        \"ENABLE_CORS\": os.getenv(\"ENABLE_CORS\"),\n        \"ENABLE_CACHING\": os.getenv(\"ENABLE_CACHING\"),\n        \"SITES_DIR\": os.getenv(\"SITES_DIR\"),\n        \"AUTOCREATE_DIRS\": os.getenv(\"AUTOCREATE_DIRS\"),",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "setup_signal_handlers",
        "kind": 2,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "def setup_signal_handlers():\n    \"\"\"\n    Register signal handlers to enable graceful shutdown of the server on SIGTERM and SIGINT signals.\n    \"\"\"\n    import signal\n    def signal_handler(signum, frame):\n        print(f\"\\n🔔 Received signal {signum}\")\n        print(\"🛑 Shutting down gracefully...\")\n        os._exit(0)\n    # Register signal handlers if available",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "def main():\n    \"\"\"\n    Starts the unified web server for the LED Matrix Control Center as a standalone application.\n    Initializes signal handlers for graceful shutdown, optionally prints environment configuration if debug mode is enabled, and launches the server.\n    \"\"\"\n    # Setup signal handlers\n    setup_signal_handlers()\n    # Print environment info if DEBUG is set\n    if os.getenv(\"DEBUG\", \"false\").lower() == \"true\":\n        print(\"🐛 Debug mode enabled\")",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "modules.web_server",
        "description": "modules.web_server",
        "peekOfCode": "logger = logging.getLogger(\"WebServer\")\ndef get_env_config():\n    \"\"\"Get environment configuration for debugging\"\"\"\n    env_vars = {\n        \"WEB_SERVER_PORT\": os.getenv(\"WEB_SERVER_PORT\"),\n        \"WEB_SERVER_HOST\": os.getenv(\"WEB_SERVER_HOST\"),\n        \"API_PROXY_PORT\": os.getenv(\"API_PROXY_PORT\"),\n        \"ENABLE_CORS\": os.getenv(\"ENABLE_CORS\"),\n        \"ENABLE_CACHING\": os.getenv(\"ENABLE_CACHING\"),\n        \"SITES_DIR\": os.getenv(\"SITES_DIR\"),",
        "detail": "modules.web_server",
        "documentation": {}
    },
    {
        "label": "WiringDiagramGenerator",
        "kind": 6,
        "importPath": "modules.wiring_diagram_generator",
        "description": "modules.wiring_diagram_generator",
        "peekOfCode": "class WiringDiagramGenerator:\n    def __init__(self):\n        self.controllers = {\n            \"arduino_uno\": {\n                \"name\": \"Arduino Uno\",\n                \"voltage\": \"5V\",\n                \"default_pin\": 6,\n                \"needs_level_shifter\": False,\n                \"color\": \"#1a1a2e\",\n            },",
        "detail": "modules.wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "modules.wiring_diagram_generator",
        "description": "modules.wiring_diagram_generator",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"Generate LED Matrix Wiring Diagrams\")\n    parser.add_argument(\n        \"controller\",\n        choices=[\"arduino_uno\", \"arduino_nano\", \"esp32\", \"esp8266\"],\n        help=\"Controller type\",\n    )\n    parser.add_argument(\"width\", type=int, help=\"Matrix width in LEDs\")\n    parser.add_argument(\"height\", type=int, help=\"Matrix height in LEDs\")\n    parser.add_argument(\"--data-pin\", type=int, help=\"Data pin number\")",
        "detail": "modules.wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "run_all_tests",
        "kind": 2,
        "importPath": "tests.run_all_tests",
        "description": "tests.run_all_tests",
        "peekOfCode": "def run_all_tests() -> bool:\n    \"\"\"Run all test suites\"\"\"\n    loader = unittest.TestLoader()\n    # Discover and load all tests\n    test_dir = os.path.dirname(__file__)\n    suite = loader.discover(test_dir, pattern='test_*.py')\n    # Run the tests\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    # Print summary",
        "detail": "tests.run_all_tests",
        "documentation": {}
    },
    {
        "label": "sys.argv",
        "kind": 5,
        "importPath": "tests.run_tests",
        "description": "tests.run_tests",
        "peekOfCode": "sys.argv = ['matrix.py', 'test'] + sys.argv[1:]\ntry:\n    from matrix import main\n    success = main()\n    sys.exit(0 if success else 1)\nexcept Exception as e:\n    print(f\"❌ Error running unified entry point: {e}\")\n    print(\"Falling back to direct test execution...\")\n    # Fallback to direct execution\n    try:",
        "detail": "tests.run_tests",
        "documentation": {}
    },
    {
        "label": "TestArduinoGenerator",
        "kind": 6,
        "importPath": "tests.test_arduino_generator",
        "description": "tests.test_arduino_generator",
        "peekOfCode": "class TestArduinoGenerator(unittest.TestCase):\n    \"\"\"Test cases for Arduino code generator\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.generator = ArduinoGenerator()\n        self.test_config = get_test_config()\n        self.temp_dir = tempfile.mkdtemp()\n    def tearDown(self):\n        \"\"\"Clean up test fixtures\"\"\"\n        import shutil",
        "detail": "tests.test_arduino_generator",
        "documentation": {}
    },
    {
        "label": "TestArduinoGeneratorIntegration",
        "kind": 6,
        "importPath": "tests.test_arduino_generator",
        "description": "tests.test_arduino_generator",
        "peekOfCode": "class TestArduinoGeneratorIntegration(unittest.TestCase):\n    \"\"\"Integration tests for Arduino generator with other modules\"\"\"\n    def setUp(self):\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.generator = ArduinoGenerator()\n        self.temp_dir = tempfile.mkdtemp()\n    def tearDown(self):\n        \"\"\"Clean up integration test fixtures\"\"\"\n        import shutil\n        if os.path.exists(self.temp_dir):",
        "detail": "tests.test_arduino_generator",
        "documentation": {}
    },
    {
        "label": "run_legacy_tests",
        "kind": 2,
        "importPath": "tests.test_arduino_generator",
        "description": "tests.test_arduino_generator",
        "peekOfCode": "def run_legacy_tests():\n    \"\"\"Run the original test functions for compatibility\"\"\"\n    print(\"🔧 Running Legacy Arduino Generator Tests\")\n    print(\"=\" * 50)\n    generator = ArduinoGenerator()\n    # Show available models\n    print(\"\\n📋 Available Arduino Models:\")\n    models = get_model_display_names()\n    for key, name in models.items():\n        print(f\"  - {key}: {name}\")",
        "detail": "tests.test_arduino_generator",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_arduino_generator",
        "description": "tests.test_arduino_generator",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom arduino_generator import ArduinoGenerator\nfrom arduino_models import get_model_display_names, validate_model, get_model_info\nfrom tests import get_test_config\nclass TestArduinoGenerator(unittest.TestCase):\n    \"\"\"Test cases for Arduino code generator\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"",
        "detail": "tests.test_arduino_generator",
        "documentation": {}
    },
    {
        "label": "TestArduinoModels",
        "kind": 6,
        "importPath": "tests.test_arduino_models",
        "description": "tests.test_arduino_models",
        "peekOfCode": "class TestArduinoModels(unittest.TestCase):\n    \"\"\"Test cases for Arduino model definitions and basic functions\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.test_config = get_test_config()\n    def test_model_definitions_completeness(self):\n        \"\"\"Test that all model definitions have required fields\"\"\"\n        required_fields = [\n            'name', 'display_name', 'voltage', 'default_pin',\n            'memory_sram', 'memory_flash', 'needs_level_shifter',",
        "detail": "tests.test_arduino_models",
        "documentation": {}
    },
    {
        "label": "TestArduinoModelCalculations",
        "kind": 6,
        "importPath": "tests.test_arduino_models",
        "description": "tests.test_arduino_models",
        "peekOfCode": "class TestArduinoModelCalculations(unittest.TestCase):\n    \"\"\"Test cases for mathematical calculations in Arduino models\"\"\"\n    def test_power_requirements_calculation(self):\n        \"\"\"Test power requirements calculation\"\"\"\n        # Test with standard values\n        power_req = calculate_power_requirements(100, 100)  # 100 LEDs at 100% brightness\n        self.assertIn('total_power_watts', power_req)\n        self.assertIn('total_current_amps', power_req)\n        self.assertIn('recommended_psu_watts', power_req)\n        self.assertIn('safety_margin_percent', power_req)",
        "detail": "tests.test_arduino_models",
        "documentation": {}
    },
    {
        "label": "TestArduinoModelsMathematicalFunctions",
        "kind": 6,
        "importPath": "tests.test_arduino_models",
        "description": "tests.test_arduino_models",
        "peekOfCode": "class TestArduinoModelsMathematicalFunctions(unittest.TestCase):\n    \"\"\"Test cases for mathematical functions using the math module\"\"\"\n    def test_math_module_usage(self):\n        \"\"\"Test that math module functions are used correctly\"\"\"\n        # Test power calculations use math.ceil\n        power_req = calculate_power_requirements(100, 75)\n        # Should use ceiling for power requirements\n        expected_power = math.ceil(100 * 0.06 * 0.75 * 5 * 1.2)  # LEDs * current * brightness * voltage * safety\n        self.assertEqual(power_req['total_power_watts'], expected_power)\n        # Test matrix dimensions use math.sqrt",
        "detail": "tests.test_arduino_models",
        "documentation": {}
    },
    {
        "label": "run_arduino_models_validation",
        "kind": 2,
        "importPath": "tests.test_arduino_models",
        "description": "tests.test_arduino_models",
        "peekOfCode": "def run_arduino_models_validation():\n    \"\"\"Run validation tests for Arduino models\"\"\"\n    print(\"🔧 Running Arduino Models Validation Tests\")\n    print(\"=\" * 50)\n    try:\n        # Test 1: All models have consistent data\n        print(\"\\n📝 Test 1: Model Data Consistency\")\n        for model_key in ARDUINO_MODELS.keys():\n            model = get_model_info(model_key)\n            assert model is not None",
        "detail": "tests.test_arduino_models",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_arduino_models",
        "description": "tests.test_arduino_models",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom arduino_models import (\n    ARDUINO_MODELS,\n    get_model_info,\n    get_available_models,\n    get_model_display_names,\n    validate_model,\n    get_recommended_model_for_leds,",
        "detail": "tests.test_arduino_models",
        "documentation": {}
    },
    {
        "label": "test_imports",
        "kind": 2,
        "importPath": "tests.test_async",
        "description": "tests.test_async",
        "peekOfCode": "def test_imports():\n    \"\"\"Test that all required modules can be imported\"\"\"\n    print(\"🧪 Testing imports...\")\n    try:\n        from matrix_controller import WebMatrixController\n        print(\"✅ WebMatrixController imported successfully\")\n    except ImportError as e:\n        print(f\"❌ Failed to import WebMatrixController: {e}\")\n        return False\n    try:",
        "detail": "tests.test_async",
        "documentation": {}
    },
    {
        "label": "test_controller_creation",
        "kind": 2,
        "importPath": "tests.test_async",
        "description": "tests.test_async",
        "peekOfCode": "def test_controller_creation():\n    \"\"\"Test creating the controller instance\"\"\"\n    print(\"\\n🏗️  Testing controller creation...\")\n    try:\n        from matrix_controller import WebMatrixController\n        # Test with async mode\n        controller = WebMatrixController(port=8081, use_async=True)\n        print(\"✅ Async controller created successfully\")\n        # Test with sync mode\n        controller_sync = WebMatrixController(port=8082, use_async=False)",
        "detail": "tests.test_async",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.test_async",
        "description": "tests.test_async",
        "peekOfCode": "def main():\n    \"\"\"Run basic tests\"\"\"\n    print(\"🚀 LED Matrix Async Controller Test\")\n    print(\"=\" * 50)\n    # Test imports\n    import_result = test_imports()\n    if not import_result:\n        print(\"\\n❌ Import tests failed\")\n        return False\n    imports_ok, async_available = import_result",
        "detail": "tests.test_async",
        "documentation": {}
    },
    {
        "label": "TestCmdController",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdController(unittest.TestCase):\n    \"\"\"Test cases for cmd_controller function\"\"\"\n    @patch('builtins.print')\n    @patch('commands.WebMatrixController')\n    def test_cmd_controller_success(self, mock_controller_class, mock_print):\n        \"\"\"Test successful controller startup\"\"\"\n        # Arrange\n        mock_controller = Mock()\n        mock_controller_class.return_value = mock_controller\n        args = Mock()",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdStart",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdStart(unittest.TestCase):\n    \"\"\"Test cases for cmd_start function\"\"\"\n    @patch('builtins.print')\n    @patch('threading.Thread')\n    @patch('time.sleep')\n    @patch('commands.WebMatrixController')\n    @patch('commands.UnifiedMatrixWebServer')\n    @patch('commands.config')\n    def test_cmd_start_success_setup(self, mock_config, mock_server_class, mock_controller_class, mock_sleep, mock_thread, mock_print):\n        \"\"\"Test successful start command setup (before keyboard interrupt)\"\"\"",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdGenerate",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdGenerate(unittest.TestCase):\n    \"\"\"Test cases for cmd_generate function\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.args = Mock()\n        self.args.model = \"uno\"\n        self.args.width = 16\n        self.args.height = 16\n        self.args.compare = False\n        self.args.organized = False",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdDesign",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdDesign(unittest.TestCase):\n    \"\"\"Test cases for cmd_design function\"\"\"\n    def setUp(self):\n        self.args = Mock()\n        self.args.samples = False\n        self.args.interactive = False\n        self.args.width = 16\n        self.args.height = 16\n    @patch('builtins.print')\n    @patch('commands.create_sample_designs')",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdWiring",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdWiring(unittest.TestCase):\n    \"\"\"Test cases for cmd_wiring function\"\"\"\n    def setUp(self):\n        self.args = Mock()\n        self.args.controller = \"uno\"\n        self.args.width = 16\n        self.args.height = 16\n        self.args.data_pin = 6\n        self.args.psu = \"5V\"\n    @patch('builtins.print')",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdConfig",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdConfig(unittest.TestCase):\n    \"\"\"Test cases for cmd_config function\"\"\"\n    def setUp(self):\n        self.args = Mock()\n        self.args.show = False\n        self.args.interactive = False\n        self.args.width = None\n        self.args.height = None\n        self.args.brightness = None\n        self.args.port = None",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdTest",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdTest(unittest.TestCase):\n    \"\"\"Test cases for cmd_test function\"\"\"\n    def setUp(self):\n        self.args = Mock()\n        self.args.module = None\n    @patch('builtins.print')\n    @patch('commands.main')\n    def test_cmd_test_full_suite(self, mock_main, mock_print):\n        \"\"\"Test running full test suite\"\"\"\n        # Arrange",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestCmdInfo",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestCmdInfo(unittest.TestCase):\n    \"\"\"Test cases for cmd_info function\"\"\"\n    def setUp(self):\n        self.args = Mock()\n    @patch('builtins.print')\n    @patch('commands.config')\n    @patch('builtins.__import__')\n    def test_cmd_info_success(self, mock_import, mock_config, mock_print):\n        \"\"\"Test successful info display\"\"\"\n        # Arrange",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestEdgeCasesAndErrorHandling",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestEdgeCasesAndErrorHandling(unittest.TestCase):\n    \"\"\"Test edge cases and error handling scenarios\"\"\"\n    def test_empty_args_handling(self):\n        \"\"\"Test command functions with empty or None args\"\"\"\n        # Test with None args - should not crash\n        from contextlib import suppress\n        with suppress(AttributeError):\n            cmd_controller(None)\n    @patch('builtins.print')\n    def test_missing_dependencies_graceful_handling(self, mock_print):",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestThreadingSafety",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestThreadingSafety(unittest.TestCase):\n    \"\"\"Test threading-related functionality\"\"\"\n    @patch('threading.Thread')\n    @patch('time.sleep')\n    def test_cmd_start_thread_daemon_setting(self, mock_sleep, mock_thread):\n        \"\"\"Test that threads are properly configured as daemon threads\"\"\"\n        # Arrange\n        mock_controller_thread = Mock()\n        mock_web_thread = Mock()\n        mock_thread.side_effect = [mock_controller_thread, mock_web_thread]",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestInputValidation",
        "kind": 6,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "class TestInputValidation(unittest.TestCase):\n    \"\"\"Test input validation and sanitization\"\"\"\n    @patch('builtins.print')\n    @patch('commands.validate_model')\n    def test_cmd_generate_model_validation(self, mock_validate, mock_print):\n        \"\"\"Test model validation in generate command\"\"\"\n        # Test various invalid models\n        invalid_models = [\"invalid\", \"\", \"UNKNOWN\", \"raspberry_pi\"]\n        for model in invalid_models:\n            args = Mock()",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "current_dir = os.path.dirname(os.path.abspath(__file__))\nparent_dir = os.path.dirname(current_dir)\nmodules_dir = os.path.join(parent_dir, \"modules\")\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, modules_dir)\n# Import the command functions to test\nfrom commands import (\n    cmd_controller,\n    cmd_start,\n    cmd_generate,",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "parent_dir = os.path.dirname(current_dir)\nmodules_dir = os.path.join(parent_dir, \"modules\")\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, modules_dir)\n# Import the command functions to test\nfrom commands import (\n    cmd_controller,\n    cmd_start,\n    cmd_generate,\n    cmd_design,",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "modules_dir",
        "kind": 5,
        "importPath": "tests.test_commands",
        "description": "tests.test_commands",
        "peekOfCode": "modules_dir = os.path.join(parent_dir, \"modules\")\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, modules_dir)\n# Import the command functions to test\nfrom commands import (\n    cmd_controller,\n    cmd_start,\n    cmd_generate,\n    cmd_design,\n    cmd_wiring,",
        "detail": "tests.test_commands",
        "documentation": {}
    },
    {
        "label": "TestModuleIntegration",
        "kind": 6,
        "importPath": "tests.test_integration",
        "description": "tests.test_integration",
        "peekOfCode": "class TestModuleIntegration(unittest.TestCase):\n    \"\"\"Test integration between different modules\"\"\"\n    def setUp(self):\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config = get_test_config()\n    def tearDown(self):\n        \"\"\"Clean up integration test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)",
        "detail": "tests.test_integration",
        "documentation": {}
    },
    {
        "label": "TestEndToEndWorkflows",
        "kind": 6,
        "importPath": "tests.test_integration",
        "description": "tests.test_integration",
        "peekOfCode": "class TestEndToEndWorkflows(unittest.TestCase):\n    \"\"\"Test complete end-to-end workflows\"\"\"\n    def setUp(self):\n        \"\"\"Set up end-to-end test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config = get_test_config()\n    def tearDown(self):\n        \"\"\"Clean up end-to-end test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)",
        "detail": "tests.test_integration",
        "documentation": {}
    },
    {
        "label": "TestErrorHandlingIntegration",
        "kind": 6,
        "importPath": "tests.test_integration",
        "description": "tests.test_integration",
        "peekOfCode": "class TestErrorHandlingIntegration(unittest.TestCase):\n    \"\"\"Test error handling across module boundaries\"\"\"\n    def test_invalid_model_error_propagation(self):\n        \"\"\"Test that invalid model errors propagate correctly\"\"\"\n        from arduino_generator import ArduinoGenerator\n        generator = ArduinoGenerator()\n        # Should raise ValueError for invalid model\n        with self.assertRaises(ValueError):\n            generator.generate_code(\"invalid_model\")\n    def test_file_operation_error_handling(self):",
        "detail": "tests.test_integration",
        "documentation": {}
    },
    {
        "label": "run_integration_validation",
        "kind": 2,
        "importPath": "tests.test_integration",
        "description": "tests.test_integration",
        "peekOfCode": "def run_integration_validation():\n    \"\"\"Run validation tests for module integration\"\"\"\n    print(\"🔧 Running Integration Validation Tests\")\n    print(\"=\" * 50)\n    temp_dir = tempfile.mkdtemp()\n    try:\n        # Test 1: Module imports and basic integration\n        print(\"\\n📝 Test 1: Module Import Integration\")\n        from matrix_config import config\n        from matrix_hardware import hardware",
        "detail": "tests.test_integration",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_integration",
        "description": "tests.test_integration",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom tests import get_test_config\nclass TestModuleIntegration(unittest.TestCase):\n    \"\"\"Test integration between different modules\"\"\"\n    def setUp(self):\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config = get_test_config()",
        "detail": "tests.test_integration",
        "documentation": {}
    },
    {
        "label": "TestPrintBanner",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestPrintBanner(unittest.TestCase):\n    \"\"\"Test the print_banner function\"\"\"\n    @patch('builtins.print')\n    @patch('matrix.datetime')\n    def test_print_banner_format(self, mock_datetime, mock_print):\n        \"\"\"Test that print_banner outputs the correct format\"\"\"\n        # Mock datetime\n        mock_datetime.now.return_value.strftime.return_value = \"2024-01-15 10:30:45\"\n        matrix.print_banner()\n        expected_calls = [",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainArgumentParsing",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainArgumentParsing(unittest.TestCase):\n    \"\"\"Test argument parsing in main function\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock all command handlers to avoid import errors\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainErrorHandling",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainErrorHandling(unittest.TestCase):\n    \"\"\"Test error handling in main function\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainQuietMode",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainQuietMode(unittest.TestCase):\n    \"\"\"Test quiet mode behavior\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock all command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainWithEdgeCases",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainWithEdgeCases(unittest.TestCase):\n    \"\"\"Test edge cases and boundary conditions\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock all command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainSystemIntegration",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainSystemIntegration(unittest.TestCase):\n    \"\"\"Test system integration aspects\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainExceptionPropagation",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainExceptionPropagation(unittest.TestCase):\n    \"\"\"Test exception propagation and handling\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainReturnValues",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainReturnValues(unittest.TestCase):\n    \"\"\"Test return value handling from commands\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock command handlers\n        self.command_mocks = {}\n        for cmd in ['cmd_controller', 'cmd_start', 'cmd_generate', 'cmd_design', \n                   'cmd_wiring', 'cmd_config', 'cmd_test', 'cmd_info']:\n            patcher = patch(f'matrix.{cmd}')\n            self.command_mocks[cmd] = patcher.start()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMainIfNameMain",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestMainIfNameMain(unittest.TestCase):\n    \"\"\"Test the __name__ == '__main__' block behavior\"\"\"\n    @patch('matrix.main')\n    @patch('sys.exit')\n    def test_main_success_exit_code_zero(self, mock_exit, mock_main):\n        \"\"\"Test that successful main execution exits with code 0\"\"\"\n        mock_main.return_value = True\n        # Simulate the __main__ execution\n        if True:  # Simulate __name__ == '__main__'\n            success = mock_main()",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestArgumentParserConfiguration",
        "kind": 6,
        "importPath": "tests.test_matrix",
        "description": "tests.test_matrix",
        "peekOfCode": "class TestArgumentParserConfiguration(unittest.TestCase):\n    \"\"\"Test argument parser configuration and choices validation\"\"\"\n    def test_generate_model_choices(self):\n        \"\"\"Test that generate command accepts only valid model choices\"\"\"\n        parser = argparse.ArgumentParser()\n        subparsers = parser.add_subparsers(dest=\"command\")\n        generate_parser = subparsers.add_parser(\"generate\")\n        generate_parser.add_argument(\"model\", choices=[\"uno\", \"nano\", \"esp32\", \"esp8266\", \"mega\"])\n        # Valid choices should not raise error\n        for model in [\"uno\", \"nano\", \"esp32\", \"esp8266\", \"mega\"]:",
        "detail": "tests.test_matrix",
        "documentation": {}
    },
    {
        "label": "TestMatrixConfig",
        "kind": 6,
        "importPath": "tests.test_matrix_config",
        "description": "tests.test_matrix_config",
        "peekOfCode": "class TestMatrixConfig(TestCase):\n    \"\"\"Test suite for MatrixConfig class\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config_file = os.path.join(self.temp_dir, \"test_config.json\")\n        self.test_config = get_test_config()\n    def tearDown(self) -> None:\n        \"\"\"Clean up test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):",
        "detail": "tests.test_matrix_config",
        "documentation": {}
    },
    {
        "label": "TestMatrixConfigIntegration",
        "kind": 6,
        "importPath": "tests.test_matrix_config",
        "description": "tests.test_matrix_config",
        "peekOfCode": "class TestMatrixConfigIntegration(unittest.TestCase):\n    \"\"\"Integration tests for matrix configuration\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config_file = os.path.join(self.temp_dir, \"integration_config.json\")\n    def tearDown(self) -> None:\n        \"\"\"Clean up integration test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)",
        "detail": "tests.test_matrix_config",
        "documentation": {}
    },
    {
        "label": "run_config_validation_tests",
        "kind": 2,
        "importPath": "tests.test_matrix_config",
        "description": "tests.test_matrix_config",
        "peekOfCode": "def run_config_validation_tests() -> Optional[bool]:\n    \"\"\"Run validation tests to ensure config works with real scenarios\"\"\"\n    print(\"🔧 Running Matrix Config Validation Tests\")\n    print(\"=\" * 50)\n    temp_dir = tempfile.mkdtemp()\n    test_config_file = os.path.join(temp_dir, \"validation_config.json\")\n    try:\n        # Test 1: Basic configuration lifecycle\n        print(\"\\n📝 Test 1: Basic Configuration Lifecycle\")\n        config = MatrixConfig(test_config_file)",
        "detail": "tests.test_matrix_config",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_matrix_config",
        "description": "tests.test_matrix_config",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom unittest.mock import patch\nimport time\nfrom unittest import TestCase\nimport contextlib\n# Import the module under test\nimport sys\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))",
        "detail": "tests.test_matrix_config",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixController",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestWebMatrixController(unittest.TestCase):\n    \"\"\"Test cases for WebMatrixController class\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures before each test method\"\"\"\n        # Mock external dependencies before importing\n        self.mock_config = MagicMock()\n        self.mock_config.get.side_effect = lambda key, default=None: {\n            'matrix_width': 16,\n            'matrix_height': 16,\n            'connection_mode': 'USB',",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixControllerIntegration",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestWebMatrixControllerIntegration(unittest.TestCase):\n    \"\"\"Integration tests for WebMatrixController\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.mock_hardware = MagicMock()\n        # Patch imports\n        self.config_patcher = patch('matrix_config.config', self.mock_config)\n        self.hardware_patcher = patch('matrix_hardware.hardware', self.mock_hardware)\n        self.wiring_patcher = patch('wiring_diagram_generator.WiringDiagramGenerator')\n        self.server_patcher = patch('socketserver.ThreadingTCPServer')",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestWebHandlerMethods",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestWebHandlerMethods(unittest.TestCase):\n    \"\"\"Test cases for WebHandler methods within WebMatrixController\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock dependencies\n        self.mock_config = MagicMock()\n        self.mock_config.get.side_effect = lambda key, default=None: {\n            'matrix_width': 16,\n            'matrix_height': 16,\n            'connection_mode': 'USB',",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixControllerUtilityFunctions",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestWebMatrixControllerUtilityFunctions(unittest.TestCase):\n    \"\"\"Test utility functions at the end of the file\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures\"\"\"\n        self.patches = [\n            patch.dict('sys.modules', {\n                'matrix_config': MagicMock(),\n                'matrix_hardware': MagicMock(),\n                'wiring_diagram_generator': MagicMock(),\n                'arduino_generator': MagicMock(),",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixControllerWebHandlerHelpers",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestWebMatrixControllerWebHandlerHelpers(unittest.TestCase):\n    \"\"\"Test cases for web server helper functionality\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures\"\"\"\n        self.patches = [\n            patch.dict('sys.modules', {\n                'matrix_config': MagicMock(),\n                'matrix_hardware': MagicMock(),\n                'wiring_diagram_generator': MagicMock(),\n                'arduino_generator': MagicMock(),",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestUtilityMethods",
        "kind": 6,
        "importPath": "tests.test_matrix_controller",
        "description": "tests.test_matrix_controller",
        "peekOfCode": "class TestUtilityMethods(unittest.TestCase):\n    \"\"\"Test cases for utility methods in WebMatrixController\"\"\"\n    def test_mermaid_diagram_generation(self):\n        \"\"\"Test Mermaid diagram generation structure\"\"\"\n        controller_type = \"arduino_uno\"\n        width, height = 16, 16\n        power_supply = \"5V10A\"\n        total_leds = width * height\n        self.assertEqual(total_leds, 256)\n        self.assertIn(\"arduino\", controller_type)",
        "detail": "tests.test_matrix_controller",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixControllerIntegration",
        "kind": 6,
        "importPath": "tests.test_matrix_controller_integration",
        "description": "tests.test_matrix_controller_integration",
        "peekOfCode": "class TestWebMatrixControllerIntegration(unittest.TestCase):\n    \"\"\"Integration test cases for WebMatrixController\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test fixtures\"\"\"\n        # Mock external dependencies\n        self.mock_config = MagicMock()\n        self.mock_config.get.side_effect = lambda key, default=None: {\n            'matrix_width': 16,\n            'matrix_height': 16,\n            'connection_mode': 'USB',",
        "detail": "tests.test_matrix_controller_integration",
        "documentation": {}
    },
    {
        "label": "TestWebMatrixControllerEndToEnd",
        "kind": 6,
        "importPath": "tests.test_matrix_controller_integration",
        "description": "tests.test_matrix_controller_integration",
        "peekOfCode": "class TestWebMatrixControllerEndToEnd(unittest.TestCase):\n    \"\"\"End-to-end test scenarios\"\"\"\n    @patch('matrix_config.config')\n    @patch('matrix_hardware.hardware')\n    @patch('wiring_diagram_generator.WiringDiagramGenerator')\n    @patch('socketserver.ThreadingTCPServer')\n    @patch('threading.Thread')\n    def test_typical_usage_scenario(\n        self,\n        _mock_thread: MagicMock,",
        "detail": "tests.test_matrix_controller_integration",
        "documentation": {}
    },
    {
        "label": "TestMatrixDesign",
        "kind": 6,
        "importPath": "tests.test_matrix_design_library",
        "description": "tests.test_matrix_design_library",
        "peekOfCode": "class TestMatrixDesign(unittest.TestCase):\n    \"\"\"Test cases for matrix design functionality\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config = get_test_config()\n        self.design = MatrixDesign(\n            width=self.test_config[\"default_matrix_width\"],\n            height=self.test_config[\"default_matrix_height\"]\n        )",
        "detail": "tests.test_matrix_design_library",
        "documentation": {}
    },
    {
        "label": "TestMatrixDesignAdvancedFeatures",
        "kind": 6,
        "importPath": "tests.test_matrix_design_library",
        "description": "tests.test_matrix_design_library",
        "peekOfCode": "class TestMatrixDesignAdvancedFeatures(unittest.TestCase):\n    \"\"\"Test cases for advanced matrix design features using numpy, time, and os\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures for advanced features\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.design = MatrixDesign(16, 16)\n    def tearDown(self):\n        \"\"\"Clean up test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)",
        "detail": "tests.test_matrix_design_library",
        "documentation": {}
    },
    {
        "label": "TestMatrixDesignUtilities",
        "kind": 6,
        "importPath": "tests.test_matrix_design_library",
        "description": "tests.test_matrix_design_library",
        "peekOfCode": "class TestMatrixDesignUtilities(unittest.TestCase):\n    \"\"\"Test cases for utility functions and helper methods\"\"\"\n    def test_color_conversion_utilities(self):\n        \"\"\"Test color conversion utility functions\"\"\"\n        # Test hex to RGB\n        rgb = MatrixDesign.hex_to_rgb('#ff0080')\n        self.assertEqual(rgb, (255, 0, 128))\n        # Test RGB to hex\n        hex_color = MatrixDesign.rgb_to_hex(255, 0, 128)\n        self.assertEqual(hex_color, '#ff0080')",
        "detail": "tests.test_matrix_design_library",
        "documentation": {}
    },
    {
        "label": "run_design_library_validation",
        "kind": 2,
        "importPath": "tests.test_matrix_design_library",
        "description": "tests.test_matrix_design_library",
        "peekOfCode": "def run_design_library_validation():\n    \"\"\"Run validation tests for matrix design library\"\"\"\n    print(\"🔧 Running Matrix Design Library Validation Tests\")\n    print(\"=\" * 50)\n    temp_dir = tempfile.mkdtemp()\n    try:\n        # Test 1: Basic design operations\n        print(\"\\n📝 Test 1: Basic Design Operations\")\n        design = MatrixDesign(16, 16)\n        # Test pattern generation",
        "detail": "tests.test_matrix_design_library",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_matrix_design_library",
        "description": "tests.test_matrix_design_library",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom matrix_design_library import MatrixDesign\nfrom tests import get_test_config\nclass TestMatrixDesign(unittest.TestCase):\n    \"\"\"Test cases for matrix design functionality\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()",
        "detail": "tests.test_matrix_design_library",
        "documentation": {}
    },
    {
        "label": "TestUnifiedWebServer",
        "kind": 6,
        "importPath": "tests.test_unified_web_server",
        "description": "tests.test_unified_web_server",
        "peekOfCode": "class TestUnifiedWebServer(unittest.TestCase):\n    \"\"\"Test cases for the unified web server\"\"\"\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Set up test server\"\"\"\n        cls.test_port = 3001  # Use different port for testing\n        cls.server = UnifiedMatrixWebServer(port=cls.test_port)\n        cls.base_url = f\"http://localhost:{cls.test_port}\"\n        # Start server in background thread\n        cls.server_thread = threading.Thread(target=cls.server.start, daemon=True)",
        "detail": "tests.test_unified_web_server",
        "documentation": {}
    },
    {
        "label": "TestNavigationIntegration",
        "kind": 6,
        "importPath": "tests.test_unified_web_server",
        "description": "tests.test_unified_web_server",
        "peekOfCode": "class TestNavigationIntegration(unittest.TestCase):\n    \"\"\"Test navigation integration between interfaces\"\"\"\n    def setUp(self):\n        self.base_url = \"http://localhost:3001\"  # Use test server\n    def test_cross_interface_navigation(self):\n        \"\"\"Test navigation between control and documentation\"\"\"\n        # Start at landing page\n        response = requests.get(self.base_url)\n        self.assertIn(\"/control\", response.text)\n        self.assertIn(\"/docs\", response.text)",
        "detail": "tests.test_unified_web_server",
        "documentation": {}
    },
    {
        "label": "TestPerformance",
        "kind": 6,
        "importPath": "tests.test_unified_web_server",
        "description": "tests.test_unified_web_server",
        "peekOfCode": "class TestPerformance(unittest.TestCase):\n    \"\"\"Test performance aspects of the unified server\"\"\"\n    def setUp(self):\n        self.base_url = \"http://localhost:3001\"  # Use test server\n    def test_response_times(self):\n        \"\"\"Test that response times are reasonable\"\"\"\n        start_time = time.time()\n        response = requests.get(self.base_url)\n        response_time = time.time() - start_time\n        self.assertEqual(response.status_code, 200)",
        "detail": "tests.test_unified_web_server",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 2,
        "importPath": "tests.test_unified_web_server",
        "description": "tests.test_unified_web_server",
        "peekOfCode": "def run_tests():\n    \"\"\"Run all tests\"\"\"\n    print(\"🧪 Starting Unified Web Server Test Suite\")\n    print(\"=\" * 50)\n    # Create test suite\n    loader = unittest.TestLoader()\n    suite = unittest.TestSuite()\n    # Add test cases\n    suite.addTests(loader.loadTestsFromTestCase(TestUnifiedWebServer))\n    suite.addTests(loader.loadTestsFromTestCase(TestNavigationIntegration))",
        "detail": "tests.test_unified_web_server",
        "documentation": {}
    },
    {
        "label": "TestGetEnvConfig",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestGetEnvConfig(unittest.TestCase):\n    \"\"\"Test environment configuration function\"\"\"\n    @patch.dict('os.environ', {\n        'WEB_SERVER_PORT': '3001',\n        'WEB_SERVER_HOST': 'testhost',\n        'API_PROXY_PORT': '8081',\n        'ENABLE_CORS': 'false',\n        'ENABLE_CACHING': 'true',\n        'SITES_DIR': '/test/sites',\n        'AUTOCREATE_DIRS': 'true',",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestServerConfig",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestServerConfig(unittest.TestCase):\n    \"\"\"Test ServerConfig dataclass\"\"\"\n    @patch.dict('os.environ', {}, clear=True)\n    def test_server_config_defaults(self):\n        \"\"\"Test ServerConfig uses correct default values\"\"\"\n        config = ServerConfig()\n        self.assertEqual(config.port, 3000)\n        self.assertEqual(config.host, \"localhost\")\n        self.assertEqual(config.control_path, \"sites/control\")\n        self.assertEqual(config.docs_path, \"sites/docs\")",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestUnifiedMatrixWebServerInit",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestUnifiedMatrixWebServerInit(unittest.TestCase):\n    \"\"\"Test UnifiedMatrixWebServer initialization\"\"\"\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n    @patch.dict('os.environ', {'SITES_DIR': '/custom/sites'}, clear=True)\n    def test_init_custom_sites_dir(self):\n        \"\"\"Test initialization with custom sites directory\"\"\"\n        server = UnifiedMatrixWebServer(port=3001)\n        self.assertEqual(server.config.port, 3001)",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestCreateLandingPage",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestCreateLandingPage(unittest.TestCase):\n    \"\"\"Test landing page creation\"\"\"\n    def setUp(self):\n        self.server = UnifiedMatrixWebServer()\n    def test_create_landing_page_returns_html(self):\n        \"\"\"Test that create_landing_page returns valid HTML\"\"\"\n        html = self.server.create_landing_page()\n        self.assertIsInstance(html, str)\n        self.assertTrue(html.startswith('<!DOCTYPE html>'))\n        self.assertIn('<html lang=\"en\">', html)",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestRequestHandlerRouting",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestRequestHandlerRouting(unittest.TestCase):\n    \"\"\"Test HTTP request handler routing logic\"\"\"\n    def setUp(self):\n        self.server = UnifiedMatrixWebServer()\n        self.handler_class = self.server.create_custom_handler()\n    def create_mock_handler(self, path, method='GET'):\n        \"\"\"Create a mock request handler for testing\"\"\"\n        handler = MagicMock(spec=self.handler_class)\n        handler.path = path\n        handler.command = method",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestStaticFileServing",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestStaticFileServing(unittest.TestCase):\n    \"\"\"Test static file serving functionality\"\"\"\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n        self.server = UnifiedMatrixWebServer()\n        self.handler_class = self.server.create_custom_handler()\n    def create_mock_handler_for_static(self):\n        \"\"\"Create a mock handler for static file testing\"\"\"\n        handler = MagicMock()",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestAPIProxy",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestAPIProxy(unittest.TestCase):\n    \"\"\"Test API proxy functionality\"\"\"\n    def setUp(self):\n        self.server = UnifiedMatrixWebServer()\n        self.handler_class = self.server.create_custom_handler()\n    def create_mock_handler_for_api(self, method='GET'):\n        \"\"\"Create a mock handler for API testing\"\"\"\n        handler = MagicMock()\n        handler.command = method\n        handler.headers = {'Content-Type': 'application/json', 'Content-Length': '0'}",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestErrorPages",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestErrorPages(unittest.TestCase):\n    \"\"\"Test error page serving functionality\"\"\"\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n        self.server = UnifiedMatrixWebServer()\n        self.server.errors_dir = Path(self.temp_dir)\n        self.handler_class = self.server.create_custom_handler()\n    def create_mock_handler_for_errors(self):\n        \"\"\"Create a mock handler for error page testing\"\"\"",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestCORSHeaders",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestCORSHeaders(unittest.TestCase):\n    \"\"\"Test CORS headers functionality\"\"\"\n    def setUp(self):\n        self.server = UnifiedMatrixWebServer()\n        self.handler_class = self.server.create_custom_handler()\n    def create_mock_handler_for_cors(self):\n        \"\"\"Create a mock handler for CORS testing\"\"\"\n        handler = MagicMock()\n        handler.send_header = MagicMock()\n        actual_handler = self.handler_class(MagicMock(), MagicMock(), MagicMock())",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestServerStart",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestServerStart(unittest.TestCase):\n    \"\"\"Test server start functionality\"\"\"\n    def setUp(self):\n        self.server = UnifiedMatrixWebServer(port=0)  # Use port 0 for testing\n    @patch('socketserver.TCPServer')\n    @patch('builtins.print')\n    def test_start_server_success(self, mock_print, mock_tcp_server):\n        \"\"\"Test successful server start\"\"\"\n        mock_httpd = MagicMock()\n        mock_tcp_server.return_value.__enter__.return_value = mock_httpd",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestSignalHandlers",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestSignalHandlers(unittest.TestCase):\n    \"\"\"Test signal handler setup\"\"\"\n    @patch('signal.signal')\n    @patch('os._exit')\n    def test_setup_signal_handlers(self, mock_signal, mock_exit):\n        \"\"\"Test that signal handlers are set up correctly\"\"\"\n        import signal\n        with patch.object(signal, 'SIGTERM', 15), \\\n             patch.object(signal, 'SIGINT', 2):\n            setup_signal_handlers()",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestMainFunction",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestMainFunction(unittest.TestCase):\n    \"\"\"Test main function\"\"\"\n    @patch('web_server.setup_signal_handlers')\n    @patch('web_server.UnifiedMatrixWebServer')\n    def test_main_function_normal_flow(self, mock_server_class, mock_setup_signals):\n        \"\"\"Test main function normal execution flow\"\"\"\n        mock_server = MagicMock()\n        mock_server_class.return_value = mock_server\n        with patch.dict('os.environ', {}, clear=True):\n            main()",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestLoggingConfiguration",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestLoggingConfiguration(unittest.TestCase):\n    \"\"\"Test logging configuration\"\"\"\n    def test_logger_configuration(self):\n        \"\"\"Test that logger is configured correctly\"\"\"\n        import logging\n        test_logger = logging.getLogger('WebServer')\n        assert test_logger.name == 'WebServer'\n        assert len(test_logger.handlers) >= 0  # May have handlers from module import\nclass TestIntegrationScenarios(unittest.TestCase):\n    \"\"\"Integration-style tests for complex scenarios\"\"\"",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestIntegrationScenarios",
        "kind": 6,
        "importPath": "tests.test_web_server",
        "description": "tests.test_web_server",
        "peekOfCode": "class TestIntegrationScenarios(unittest.TestCase):\n    \"\"\"Integration-style tests for complex scenarios\"\"\"\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n    @patch.dict('os.environ', {\n        'SITES_DIR': None,\n        'AUTOCREATE_DIRS': 'true',\n    }, clear=True)\n    def test_full_server_initialization_with_autocreate(self):",
        "detail": "tests.test_web_server",
        "documentation": {}
    },
    {
        "label": "TestWiringDiagramGenerator",
        "kind": 6,
        "importPath": "tests.test_wiring_diagram_generator",
        "description": "tests.test_wiring_diagram_generator",
        "peekOfCode": "class TestWiringDiagramGenerator(unittest.TestCase):\n    \"\"\"Test cases for wiring diagram generator\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.test_config = get_test_config()\n        self.generator = WiringDiagramGenerator()\n    def tearDown(self):\n        \"\"\"Clean up test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):",
        "detail": "tests.test_wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "TestWiringDiagramJSONFunctionality",
        "kind": 6,
        "importPath": "tests.test_wiring_diagram_generator",
        "description": "tests.test_wiring_diagram_generator",
        "peekOfCode": "class TestWiringDiagramJSONFunctionality(unittest.TestCase):\n    \"\"\"Test cases for JSON export/import functionality\"\"\"\n    def setUp(self):\n        \"\"\"Set up JSON test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()\n        self.generator = WiringDiagramGenerator()\n    def tearDown(self):\n        \"\"\"Clean up JSON test fixtures\"\"\"\n        if os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)",
        "detail": "tests.test_wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "TestWiringDiagramIntegration",
        "kind": 6,
        "importPath": "tests.test_wiring_diagram_generator",
        "description": "tests.test_wiring_diagram_generator",
        "peekOfCode": "class TestWiringDiagramIntegration(unittest.TestCase):\n    \"\"\"Test integration with other modules\"\"\"\n    def setUp(self):\n        \"\"\"Set up integration test fixtures\"\"\"\n        self.generator = WiringDiagramGenerator()\n    def test_power_calculation_integration(self):\n        \"\"\"Test integration with arduino_models power calculations\"\"\"\n        # Test that power calculations use shared functions\n        power_req = self.generator.calculate_power_requirements(16, 16, 128)\n        # Should use the shared calculation from arduino_models",
        "detail": "tests.test_wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "run_wiring_diagram_validation",
        "kind": 2,
        "importPath": "tests.test_wiring_diagram_generator",
        "description": "tests.test_wiring_diagram_generator",
        "peekOfCode": "def run_wiring_diagram_validation():\n    \"\"\"Run validation tests for wiring diagram generator\"\"\"\n    print(\"🔧 Running Wiring Diagram Generator Validation Tests\")\n    print(\"=\" * 50)\n    temp_dir = tempfile.mkdtemp()\n    try:\n        # Test 1: Basic diagram generation\n        print(\"\\n📝 Test 1: Basic Diagram Generation\")\n        generator = WiringDiagramGenerator()\n        # Test Mermaid diagram",
        "detail": "tests.test_wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "parent_dir",
        "kind": 5,
        "importPath": "tests.test_wiring_diagram_generator",
        "description": "tests.test_wiring_diagram_generator",
        "peekOfCode": "parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, parent_dir)\nsys.path.insert(0, os.path.join(parent_dir, 'modules'))\nfrom wiring_diagram_generator import WiringDiagramGenerator\nfrom tests import get_test_config\nclass TestWiringDiagramGenerator(unittest.TestCase):\n    \"\"\"Test cases for wiring diagram generator\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.temp_dir = tempfile.mkdtemp()",
        "detail": "tests.test_wiring_diagram_generator",
        "documentation": {}
    },
    {
        "label": "print_header",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def print_header(title):\n    \"\"\"Print a formatted header\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(f\"🔍 {title}\")\n    print(\"=\" * 60)\ndef print_success(message):\n    \"\"\"Print success message\"\"\"\n    print(f\"✅ {message}\")\ndef print_error(message):\n    \"\"\"Print error message\"\"\"",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "print_success",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def print_success(message):\n    \"\"\"Print success message\"\"\"\n    print(f\"✅ {message}\")\ndef print_error(message):\n    \"\"\"Print error message\"\"\"\n    print(f\"❌ {message}\")\ndef print_warning(message):\n    \"\"\"Print warning message\"\"\"\n    print(f\"⚠️  {message}\")\ndef validate_files_exist():",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "print_error",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def print_error(message):\n    \"\"\"Print error message\"\"\"\n    print(f\"❌ {message}\")\ndef print_warning(message):\n    \"\"\"Print warning message\"\"\"\n    print(f\"⚠️  {message}\")\ndef validate_files_exist():\n    \"\"\"Validate that all required files exist\"\"\"\n    print_header(\"File Structure Validation\")\n    required_files = [",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "print_warning",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def print_warning(message):\n    \"\"\"Print warning message\"\"\"\n    print(f\"⚠️  {message}\")\ndef validate_files_exist():\n    \"\"\"Validate that all required files exist\"\"\"\n    print_header(\"File Structure Validation\")\n    required_files = [\n        \"modules/web_server.py\",\n        \"sites/control/index.html\",\n        \"sites/docs/index.html\",",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_files_exist",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_files_exist():\n    \"\"\"Validate that all required files exist\"\"\"\n    print_header(\"File Structure Validation\")\n    required_files = [\n        \"modules/web_server.py\",\n        \"sites/control/index.html\",\n        \"sites/docs/index.html\",\n        \"matrix.py\",\n        \"README.md\"\n    ]",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_unified_server_import",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_unified_server_import():\n    \"\"\"Validate that the unified server can be imported\"\"\"\n    print_header(\"Import Validation\")\n    try:\n        from modules.web_server import UnifiedMatrixWebServer\n        print_success(\"UnifiedMatrixWebServer imported successfully\")\n        return True\n    except ImportError as e:\n        print_error(f\"Failed to import UnifiedMatrixWebServer: {e}\")\n        return False",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_server_startup",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_server_startup():\n    \"\"\"Validate that the server can start up\"\"\"\n    print_header(\"Server Startup Validation\")\n    try:\n        from modules.web_server import UnifiedMatrixWebServer\n        # Test server creation\n        server = UnifiedMatrixWebServer(port=3002)  # Use different port for testing\n        print_success(\"Server instance created successfully\")\n        # Test server startup in background\n        def start_server():",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_routing",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_routing():\n    \"\"\"Validate that routing works correctly\"\"\"\n    print_header(\"Routing Validation\")\n    base_url = \"http://localhost:3002\"\n    routes_to_test = [\n        (\"/\", \"Landing page\"),\n        (\"/control\", \"Control interface\"),\n        (\"/docs\", \"Documentation\"),\n        (\"/nonexistent\", \"404 handling\")\n    ]",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_navigation_updates",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_navigation_updates():\n    \"\"\"Validate that navigation has been updated\"\"\"\n    print_header(\"Navigation Updates Validation\")\n    files_to_check = [\n        (\"sites/control/index.html\", [\"/docs\", \"Documentation\"]),\n        (\"sites/docs/index.html\", [\"/control\", \"Control Interface\"])\n    ]\n    all_updated = True\n    for file_path, expected_content in files_to_check:\n        try:",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_matrix_py_updates",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_matrix_py_updates():\n    \"\"\"Validate that matrix.py has been updated\"\"\"\n    print_header(\"Matrix.py Updates Validation\")\n    try:\n        with open(\"matrix.py\", 'r', encoding='utf-8') as f:\n            content = f.read()\n        checks = [\n            (\"UnifiedMatrixWebServer\", \"Unified server import\"),\n            (\"unified web server\", \"Unified server usage\"),\n            (\"/control\", \"Path-based routing reference\"),",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "validate_requirements",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def validate_requirements():\n    \"\"\"Validate that all requirements are met\"\"\"\n    print_header(\"Requirements Validation Summary\")\n    requirements = [\n        (\"Unified web server\", \"Single server serves both interfaces\"),\n        (\"Path-based routing\", \"Uses /control and /docs paths\"),\n        (\"Landing page\", \"Navigation page at root URL\"),\n        (\"Cross-interface navigation\", \"Links between control and docs\"),\n        (\"Error handling\", \"Custom 404 and error pages\"),\n        (\"API proxy\", \"Proxies requests to controller\"),",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tests.validate_phase4_integration",
        "description": "tests.validate_phase4_integration",
        "peekOfCode": "def main():\n    \"\"\"Main validation function\"\"\"\n    print(\"🚀 Phase 4 Integration Validation\")\n    print(\"Testing unified web server implementation...\")\n    validation_steps = [\n        (\"File Structure\", validate_files_exist),\n        (\"Import System\", validate_unified_server_import),\n        (\"Server Startup\", validate_server_startup),\n        (\"Routing System\", validate_routing),\n        (\"Navigation Updates\", validate_navigation_updates),",
        "detail": "tests.validate_phase4_integration",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "matrix",
        "description": "matrix",
        "peekOfCode": "def print_banner():\n    \"\"\"\n    Display a formatted banner with the LED Matrix Project name and the current date and time.\n    \"\"\"\n    print(\"=\" * 70)\n    print(\"🔥 LED Matrix Project - Unified Control Interface\")\n    print(\"=\" * 70)\n    print(f\"📅 {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n    print()\ndef main():",
        "detail": "matrix",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "matrix",
        "description": "matrix",
        "peekOfCode": "def main():\n    \"\"\"\n    Parses command-line arguments and dispatches commands for the LED Matrix Project CLI.\n    Returns:\n        bool: True if the selected command completes successfully, False otherwise.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"LED Matrix Project - Unified Control Interface\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"",
        "detail": "matrix",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "matrix",
        "description": "matrix",
        "peekOfCode": "current_dir = os.path.dirname(os.path.abspath(__file__))\nmodules_dir = os.path.join(current_dir, \"modules\")\nsys.path.insert(0, current_dir)\nsys.path.insert(0, modules_dir)\nfrom modules.commands import (\n    cmd_controller,\n    cmd_start,\n    cmd_generate,\n    cmd_design,\n    cmd_wiring,",
        "detail": "matrix",
        "documentation": {}
    },
    {
        "label": "modules_dir",
        "kind": 5,
        "importPath": "matrix",
        "description": "matrix",
        "peekOfCode": "modules_dir = os.path.join(current_dir, \"modules\")\nsys.path.insert(0, current_dir)\nsys.path.insert(0, modules_dir)\nfrom modules.commands import (\n    cmd_controller,\n    cmd_start,\n    cmd_generate,\n    cmd_design,\n    cmd_wiring,\n    cmd_config,",
        "detail": "matrix",
        "documentation": {}
    }
]